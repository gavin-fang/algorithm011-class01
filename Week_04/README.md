## 第4周 第九课——深度优先搜索和广度优先搜索

### DFS的递归和非递归代码模板

递归

```python
visited = set() 
def dfs(node, visited):
    if node in visited: # terminator
    	# already visited 
    	return 
	visited.add(node) 
	# process current node here. 
	...
	for next_node in node.children(): 
		if next_node not in visited: 
			dfs(next_node, visited)
```
非递归
```python
def dfs(self, tree): 
	if tree.root is None: 
		return []
	visited, stack = [], [tree.root]
	while stack: 
		node = stack.pop() 
		visited.add(node)
		process (node) 
		nodes = generate_related_nodes(node) 
		stack.push(nodes) 
	# other processing work 
	...
```
### BFS的代码模板-非递归

```python
def BFS(graph, start, end):
    visited = set()
	queue = [] 
	queue.append([start]) 
	while queue: 
		node = queue.pop() 
		visited.add(node)
		process(node) 
		nodes = generate_related_nodes(node) 
		queue.push(nodes)
	# other processing work 
	...
```
### 深度优先搜索算法

* 深度优先搜索，重点就在于“深度”一词，不碰到死胡同就不回头
* 深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法
* 整个过程和出栈入栈的过程极为相似，可以使用栈来实现
  * 首先先对问题进行分析，得到岔路口和死胡同；
  * 再定义一个栈，以深度为关键词访问这些岔道口和死胡同，并将它们入栈；
  * 而当离开这些岔道口和死胡同时，将它们出栈。
*  使用递归可以很好地实现深度优先搜索。只能说递归是深度优先搜索的一种实现方式。在使用递归时，系统会调用一个叫系统栈的东西来存放递归中每一层的状态，因此使用递归来实现DFS的本质其实还是栈。
*  注意，当DFS复杂度过高，或数据极端的情况，必要的时候需用到剪枝。
*  关于DFS参数问题，什么在变化，就把什么设置成参数。
### 广度优先搜索

* 当碰到岔道口时，总是先依次访问从该岔道口能直接到达的所有结点，然后再按这些结点被访问的顺序去依次访问它们能直接到达的所有结点，依次类推，直到所有结点都被访问为止。
* 实现步骤
1. 定义队列q，并将起点s入队；
2. 写一个while循环，循环条件是队列是q非空；
3. 在while循环中，先取出队首元素top，然后**访问**它（访问可以是任何事情，例如将其输出），访问完将其出队；
4. 将top的**下一层结点**中所有**未曾入队**的结点入队，并标记它们的层号为当前的层号加1，同时设置这些入队的结点已入过队；
5. 返回步骤2继续循环。
## 第4周 第十课——贪心算法

### 贪心与回溯、动态规划的比较

贪心：当下做局部最优判断

回溯：能够回退

动态规划：最优判断+回退

### 基本概念

* 所谓贪心算法是指，在对问题求解时，总是**做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的**局部最优解**。
* 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，**只与当前状态有关**。）
* **所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。**
### 基本思路

* 建立数学模型来描述问题
* 把求解的问题分成若干个子问题
* 对每个子问题求解，得到子问题的局部最优解
* 把子问题的解局部最优解合成原来问题的一个解
### 存在的问题

* 不能保证求得的最后解是最佳的
* 不能用来求最大值或最小值的问题
* 只能求满足某些约束条件的可行解的范围
### 适用情形

**贪心策略适用的前提是：局部最优策略能导致产生全局最优解。**

实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。

### 贪心选择性质

* **对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。**
* 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。
### 实现框架

```plain
从问题的某一初始解出发：
while (朝给定总目标前进一步)
{
利用可行的决策，求出可行解的一个解元素。
}
由所有解元素组合成问题的一个可行解；
```
## 第4周 第十一课——二分查找

### 代码模板

```python
left, right = 0, len(array) - 1 
while left <= right: 
	  mid = (left + right) / 2 
	  if array[mid] == target: 
		    # find the target!! 
		    break or return result 
	  elif array[mid] < target: 
		    left = mid + 1 
	  else: 
		    right = mid - 1
```
* **使用二分查找的条件：单调性、存在上下界、能够通过索引下标进行访问**
* **另外，计算 mid 时需要技巧防止溢出，建议写成: mid = left + (right - left) / 2**
### 搜索区间不同的情况（while语句中left<right还是left<=right）

1. 最基本的二分查找
```plain
因为我们初始化 right = nums.length - 1
所以决定了我们的「搜索区间」是 [left, right]
所以决定了 while (left <= right)
同时也决定了 left = mid+1 和 right = mid-1
因为我们只需找到一个 target 的索引即可
所以当 nums[mid] == target 时可以立即返回
```
2. 寻找左侧边界的二分查找
```plain
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid+1 和 right = mid
因为我们需找到 target 的最左侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧右侧边界以锁定左侧边界
```
3. 寻找右侧边界的二分查找
```plain
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid+1 和 right = mid
因为我们需找到 target 的最右侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧左侧边界以锁定右侧边界
又因为收紧左侧边界时必须 left = mid + 1
所以最后无论返回 left 还是 right，必须减一
```
## 刷题记录

### 0713周一

226-翻转二叉树：简单递归，交换左右子树；迭代法，用队列存树每层的结点

### 0714周二

102-二叉树的层序遍历：BFS，将每一层的节点遍历一遍，用临时列表存放，再加到最后结果

###  0715周三

200-岛屿数量：用DFS，注意终止条件，

### 0716周四

860-柠檬水找零：贪心算法的思想，找零时先考虑10美元，再考虑5美元

### 0717周五

121-买卖股票的最佳时机：暴力解法，双指针比较；贪心算法，遍历一次，分别记录最大利润和最低价格；遍历一次，滑动窗口begin和end，更新更小的begin，记录maxprofit

122-买卖股票的最佳时机II：贪心算法，比较股票价格数组中连续数值的差值，选择大于0的加入利润

### 0719周日

455-分发饼干：贪心算法，先排序，再双指针，选择刚刚好满足小朋友胃口的大小的饼干（饼干大于等于胃口）

69-x的平方根：二分查找法；牛顿迭代法，初始选x，每次迭代r=(r+x//r)//2，终止条件为r平方小于等于x

33-搜索旋转数组：二分查找，判断mid左边还是右边处于单调状态


## 用 add first 或 add last 这套新的 API 改写 Deque 的代码

Deque<String> deque = new LinkList<String>();

deque.push("a");  # deque.addFirst("a");
deque.push("b");  # deque.addFirst("b");
deque.push("c");  # deque.addFirst("c");
System.out.println(deque);  

String str = deque.peek();  # 用deque.peekFirst();
System.out.println(str);
System.out.println(deque);

while (deque.size() > 0) {
	System.out.println(deque.pop());  # 用deque.removeFirst()
}
System.out.println(deque);

------

## 一周打卡题目记录

### 0622周一

11盛最多水的容器：**双指针法，左右夹逼**（这种方法的可行性可以从二维矩阵考虑）

283移动零：**两次遍历法**，第一次把非零数移前，用变量记录非零元个数，第二次把末尾变零；**一次遍历法，用两个指针，交换零与非零元素**，考虑下指针快慢条件

70爬楼梯：**递归**；**普通动态规划**，维护一个dp[]，空间复杂度O(n)；**改进的动态规划**，用两个变量暂存前面已经计算过的值

### 0623周二

15三数之和：**先排序再用双指针**，**注意去掉重复的三元组**（选的首个target值大于零、targe值重复、双指针值重复）

1两数之和：暴力解法，双重循环；**用dict模拟哈希表**，遍历一遍数组

### 0624周三

66加一：分每一位全部为9和其余情况讨论，其余情况分要么只用加一（直接返回数组），要么变0

### 0625周四

24两两交换链表中的结点：**递归法**， 每次递归都负责交换一对节点，下一次传入前一对节点后的那个节点；**迭代法，新定义一个指向头结点的假结点**ListNode(-1)，后迭代中进行交换、更新pre和head

### 0626周五

21合并两个有序链表：**递归法，双指针**，先判空，比较大小，递归；**迭代法，新定义一个结点**ListNode(-1)，pq都不空时进行迭代，有一个为空时连结点

141环形链表：**字典当哈希**；**快慢指针，慢走一步，快走两步**，迭代终止条件慢等于快（快或快后面结点为空返回错误）

### 0627周六

26删除排序数组中的重复项：**双指针，一次遍历，记录不重复数组元素位置**（这里类似于移动零的一次遍历法）

20有效的括号：**栈加字典（闭括号：开括号）**，匹配

### 0628周日

641设计循环双端队列：**数组**实现的循环双端队列，操作时front和rear的大小注意取模运算

------

## 看视频课过程中的一些记录和想法

### 第1周 第3课 数组、链表、跳表

#### 数组ArrayList

增删O(n)，**按下标随机访问**O(1)；

申请数组时，计算机在内存中开辟了一段连续的地址，每个地址通过内存管理器访问。

#### 链表LinkedList

增删O(1)——这里的前提是**已经遍历到要删除的结点或插入结点的前驱结点，增删只需要改变 next 指针**，不需要大量挪动链表中的元素，查找O(n)——想找到一个元素必须从头结点或者尾结点一个一个的都查找一遍才能找到目标元素；

链表的工程应用，**LRU（最近最少使用）缓存机制**（leetcode146 LRU缓存机制）；

链表的访问速度比较慢，寻找一个元素需要挨个遍历，优化：**升维，空间换时间**。

#### 跳表Skip List

**只能用于元素有序的情况（谨记）；**

每一层建索引n/2, n/4, ..., n/(2^k)，增删查都是O(logn)，空间复杂度O(n)，每层索引结点数相加；

原理简单、容易实现、方便扩展、效率更高，应用于Redis、LevelDB。

### 第1周 第4课 栈、队列、优先队列、双端队列

#### 栈Stack

由一段连续的存储空间组成，特点是先进后出、后进先出，可以用数组或链表实现；

栈底base，栈顶top；

添加、删除操作皆为O(1)，将数据压入栈顶-push，将栈顶数据弹出-pop，查看栈顶数据-top；

应用：有效括号匹配、最小栈。

#### 队列Queue

由一段连续的存储空间组成，特点是先进先出、后进后出，一般也可以用数组或双向链表实现；

队尾rear，队头front；

添加、删除操作皆为O(1)，在队列尾部加入元素-enqueue(el)，取出队列的第一个元素-dequeue()，查看队列头部元素-firstEI()；

#### 优先队列Priority Queue

在许多情况下，简单的队列结构是不够的，先入先出机制需要使用某些优先规则来完善。

优先队列可以用两种链表的变种实现。一种变种是所有的**元素按照进入顺序排序，出队时按照优先级**。另一种是**根据元素的优先级决定新增元素的位置**。在这两种情况下，总的执行时间都是O(n)，在标准库中使用后一种方式实现的，因为我们希望在元素出队时可以尽可能的快。

#### 双端队列Deque

顾名思义，双端队列就是可以在队列的两端压入、弹出元素。

双端队列通过维护多个数组来避免头部插入操作造成的大量数据后移，尽管双端队列的实现比较复杂，但是作为使用者，**既可以常数时间内随机访问元素，又可以常数时间内在队列两端插入数据，结合了数组和链表的优点**，这对于某些场景下非常合适。（leetcode239 滑动窗口最大值）
